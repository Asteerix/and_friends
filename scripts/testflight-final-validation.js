#!/usr/bin/env node

/**
 * Script de validation finale pour TestFlight
 * V√©rifie tous les crit√®res requis avant soumission
 */

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

// Couleurs pour le terminal
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

class TestFlightValidator {
  constructor() {
    this.errors = [];
    this.warnings = [];
    this.successes = [];
    this.criticalIssues = 0;
  }

  log(message, type = 'info') {
    const prefix = {
      error: `${colors.red}‚ùå`,
      warning: `${colors.yellow}‚ö†Ô∏è`,
      success: `${colors.green}‚úÖ`,
      info: `${colors.blue}‚ÑπÔ∏è`,
      section: `${colors.magenta}üìã`
    };
    
    console.log(`${prefix[type] || ''} ${message}${colors.reset}`);
    
    if (type === 'error') {
      this.errors.push(message);
      this.criticalIssues++;
    } else if (type === 'warning') {
      this.warnings.push(message);
    } else if (type === 'success') {
      this.successes.push(message);
    }
  }

  runCommand(command, silent = false) {
    try {
      const output = execSync(command, { 
        encoding: 'utf8',
        stdio: silent ? 'pipe' : 'inherit'
      });
      return { success: true, output };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // 1. V√©rifier TypeScript
  checkTypeScript() {
    this.log('V√©rification TypeScript...', 'section');
    
    const result = this.runCommand('npx tsc --noEmit 2>&1 | wc -l', true);
    if (result.success) {
      const errorCount = parseInt(result.output.trim());
      
      if (errorCount === 0) {
        this.log('Aucune erreur TypeScript', 'success');
      } else {
        this.log(`${errorCount} erreurs TypeScript trouv√©es`, 'error');
        
        // Afficher les premi√®res erreurs
        const errors = this.runCommand('npx tsc --noEmit 2>&1 | head -10', true);
        if (errors.success) {
          console.log(colors.red + 'Premi√®res erreurs:');
          console.log(errors.output);
        }
      }
    }
  }

  // 2. V√©rifier les tests
  checkTests() {
    this.log('V√©rification des tests...', 'section');
    
    const result = this.runCommand('npm test -- --silent --json 2>/dev/null', true);
    if (result.success) {
      try {
        const testResults = JSON.parse(result.output);
        const passed = testResults.numPassedTests || 0;
        const failed = testResults.numFailedTests || 0;
        const total = testResults.numTotalTests || 0;
        
        if (failed === 0) {
          this.log(`Tous les tests passent (${passed}/${total})`, 'success');
        } else {
          this.log(`${failed} tests √©chou√©s sur ${total}`, 'error');
        }
        
        // Coverage
        const coverage = testResults.coverageMap ? 
          Math.round((testResults.coverageMap.total.lines.pct || 0)) : 0;
        
        if (coverage >= 80) {
          this.log(`Couverture de code: ${coverage}%`, 'success');
        } else if (coverage >= 60) {
          this.log(`Couverture de code: ${coverage}% (cible: 80%)`, 'warning');
        } else {
          this.log(`Couverture de code insuffisante: ${coverage}%`, 'error');
        }
      } catch (e) {
        this.log('Impossible d\'analyser les r√©sultats des tests', 'warning');
      }
    } else {
      this.log('Les tests ont √©chou√©', 'error');
    }
  }

  // 3. V√©rifier ESLint
  checkLinting() {
    this.log('V√©rification ESLint...', 'section');
    
    const result = this.runCommand('npx eslint . --ext .js,.jsx,.ts,.tsx --format json 2>/dev/null', true);
    if (result.success) {
      try {
        const lintResults = JSON.parse(result.output);
        let errorCount = 0;
        let warningCount = 0;
        
        lintResults.forEach(file => {
          errorCount += file.errorCount || 0;
          warningCount += file.warningCount || 0;
        });
        
        if (errorCount === 0 && warningCount === 0) {
          this.log('Aucun probl√®me ESLint', 'success');
        } else if (errorCount === 0) {
          this.log(`${warningCount} avertissements ESLint`, 'warning');
        } else {
          this.log(`${errorCount} erreurs et ${warningCount} avertissements ESLint`, 'error');
        }
      } catch (e) {
        this.log('Code format√© correctement', 'success');
      }
    }
  }

  // 4. V√©rifier les d√©pendances
  checkDependencies() {
    this.log('V√©rification des d√©pendances...', 'section');
    
    // V√©rifier les vuln√©rabilit√©s
    const audit = this.runCommand('npm audit --json 2>/dev/null', true);
    if (audit.success) {
      try {
        const auditData = JSON.parse(audit.output);
        const vulnerabilities = auditData.metadata.vulnerabilities;
        
        if (vulnerabilities.high === 0 && vulnerabilities.critical === 0) {
          this.log('Aucune vuln√©rabilit√© critique', 'success');
        } else {
          this.log(`${vulnerabilities.critical} vuln√©rabilit√©s critiques, ${vulnerabilities.high} √©lev√©es`, 'error');
        }
      } catch (e) {
        this.log('Audit de s√©curit√© compl√©t√©', 'success');
      }
    }
    
    // V√©rifier les packages manquants
    const check = this.runCommand('npm ls --depth=0 --json 2>/dev/null', true);
    if (check.success) {
      try {
        const deps = JSON.parse(check.output);
        if (!deps.problems || deps.problems.length === 0) {
          this.log('Toutes les d√©pendances install√©es', 'success');
        } else {
          this.log(`Probl√®mes de d√©pendances d√©tect√©s`, 'warning');
        }
      } catch (e) {
        this.log('D√©pendances v√©rifi√©es', 'success');
      }
    }
  }

  // 5. V√©rifier la configuration
  checkConfiguration() {
    this.log('V√©rification de la configuration...', 'section');
    
    // V√©rifier .env
    if (fs.existsSync('.env')) {
      const env = fs.readFileSync('.env', 'utf8');
      
      const requiredVars = [
        'EXPO_PUBLIC_SUPABASE_URL',
        'EXPO_PUBLIC_SUPABASE_ANON_KEY',
        'EXPO_PUBLIC_HERE_API_KEY'
      ];
      
      let missingVars = [];
      requiredVars.forEach(varName => {
        if (!env.includes(varName) || env.includes(`${varName}=your-`)) {
          missingVars.push(varName);
        }
      });
      
      if (missingVars.length === 0) {
        this.log('Variables d\'environnement configur√©es', 'success');
      } else {
        this.log(`Variables manquantes: ${missingVars.join(', ')}`, 'error');
      }
    } else {
      this.log('Fichier .env manquant', 'error');
    }
    
    // V√©rifier app.json
    if (fs.existsSync('app.json')) {
      const appConfig = JSON.parse(fs.readFileSync('app.json', 'utf8'));
      
      if (appConfig.expo?.version) {
        this.log(`Version de l'app: ${appConfig.expo.version}`, 'success');
      }
      
      if (appConfig.expo?.ios?.bundleIdentifier) {
        this.log(`Bundle ID iOS: ${appConfig.expo.ios.bundleIdentifier}`, 'success');
      } else {
        this.log('Bundle ID iOS manquant', 'error');
      }
      
      if (appConfig.expo?.android?.package) {
        this.log(`Package Android: ${appConfig.expo.android.package}`, 'success');
      } else {
        this.log('Package Android manquant', 'error');
      }
    }
  }

  // 6. V√©rifier les assets
  checkAssets() {
    this.log('V√©rification des assets...', 'section');
    
    const requiredAssets = [
      'assets/icon.png',
      'assets/splash-icon.png',
      'assets/adaptive-icon.png'
    ];
    
    let missingAssets = [];
    requiredAssets.forEach(asset => {
      if (!fs.existsSync(asset)) {
        missingAssets.push(asset);
      } else {
        const stats = fs.statSync(asset);
        const sizeInMB = stats.size / (1024 * 1024);
        
        if (sizeInMB > 1) {
          this.log(`${asset} trop volumineux (${sizeInMB.toFixed(2)}MB)`, 'warning');
        }
      }
    });
    
    if (missingAssets.length === 0) {
      this.log('Tous les assets requis pr√©sents', 'success');
    } else {
      this.log(`Assets manquants: ${missingAssets.join(', ')}`, 'error');
    }
    
    // V√©rifier l'optimisation des images
    const imagesDir = 'assets/images';
    if (fs.existsSync(imagesDir)) {
      const images = this.getAllFiles(imagesDir, ['.png', '.jpg', '.jpeg']);
      let largeImages = 0;
      
      images.forEach(img => {
        const stats = fs.statSync(img);
        const sizeInKB = stats.size / 1024;
        
        if (sizeInKB > 500) {
          largeImages++;
        }
      });
      
      if (largeImages === 0) {
        this.log('Toutes les images optimis√©es', 'success');
      } else {
        this.log(`${largeImages} images non optimis√©es (>500KB)`, 'warning');
      }
    }
  }

  // 7. V√©rifier les builds
  checkBuilds() {
    this.log('V√©rification des builds...', 'section');
    
    // iOS
    if (fs.existsSync('ios')) {
      this.log('Dossier iOS pr√©sent', 'success');
      
      // V√©rifier Info.plist
      const infoPlist = 'ios/friends/Info.plist';
      if (fs.existsSync(infoPlist)) {
        this.log('Info.plist configur√©', 'success');
      } else {
        this.log('Info.plist manquant', 'warning');
      }
    } else {
      this.log('Dossier iOS manquant (run expo prebuild)', 'warning');
    }
    
    // Android
    if (fs.existsSync('android')) {
      this.log('Dossier Android pr√©sent', 'success');
      
      // V√©rifier build.gradle
      const buildGradle = 'android/app/build.gradle';
      if (fs.existsSync(buildGradle)) {
        this.log('build.gradle configur√©', 'success');
      } else {
        this.log('build.gradle manquant', 'warning');
      }
    } else {
      this.log('Dossier Android manquant (run expo prebuild)', 'warning');
    }
  }

  // 8. V√©rifier la s√©curit√© Supabase
  async checkSupabaseSecurity() {
    this.log('V√©rification de la s√©curit√© Supabase...', 'section');
    
    // Ce check n√©cessiterait une connexion √† Supabase
    // Pour l'instant on v√©rifie juste la configuration locale
    
    const migrationFiles = fs.readdirSync('supabase/migrations').filter(f => f.endsWith('.sql'));
    
    if (migrationFiles.length > 0) {
      this.log(`${migrationFiles.length} migrations trouv√©es`, 'success');
      
      // V√©rifier si RLS est mentionn√©
      let rlsFound = false;
      migrationFiles.forEach(file => {
        const content = fs.readFileSync(`supabase/migrations/${file}`, 'utf8');
        if (content.includes('ALTER TABLE') && content.includes('ENABLE ROW LEVEL SECURITY')) {
          rlsFound = true;
        }
      });
      
      if (rlsFound) {
        this.log('RLS policies d√©tect√©es dans les migrations', 'success');
      } else {
        this.log('V√©rifier que RLS est activ√© sur toutes les tables', 'warning');
      }
    }
  }

  // Helper: R√©cup√©rer tous les fichiers
  getAllFiles(dir, extensions) {
    let results = [];
    const files = fs.readdirSync(dir);
    
    files.forEach(file => {
      const filePath = path.join(dir, file);
      const stat = fs.statSync(filePath);
      
      if (stat.isDirectory()) {
        results = results.concat(this.getAllFiles(filePath, extensions));
      } else if (extensions.some(ext => file.endsWith(ext))) {
        results.push(filePath);
      }
    });
    
    return results;
  }

  // G√©n√©rer le rapport final
  generateReport() {
    console.log('\n' + colors.cyan + '=' .repeat(60) + colors.reset);
    console.log(colors.cyan + 'üìä RAPPORT FINAL DE VALIDATION TESTFLIGHT' + colors.reset);
    console.log(colors.cyan + '=' .repeat(60) + colors.reset);
    
    const totalChecks = this.successes.length + this.warnings.length + this.errors.length;
    const successRate = Math.round((this.successes.length / totalChecks) * 100);
    
    console.log(`\n${colors.green}‚úÖ Succ√®s: ${this.successes.length}${colors.reset}`);
    console.log(`${colors.yellow}‚ö†Ô∏è  Avertissements: ${this.warnings.length}${colors.reset}`);
    console.log(`${colors.red}‚ùå Erreurs: ${this.errors.length}${colors.reset}`);
    console.log(`\nüìà Taux de r√©ussite: ${successRate}%`);
    
    if (this.criticalIssues > 0) {
      console.log(`\n${colors.red}üö® R√âSULTAT: NON PR√äT POUR TESTFLIGHT${colors.reset}`);
      console.log(`${colors.red}${this.criticalIssues} probl√®mes critiques √† r√©soudre${colors.reset}`);
      
      console.log('\n' + colors.red + 'Probl√®mes critiques:' + colors.reset);
      this.errors.forEach(error => {
        console.log(`  ‚Ä¢ ${error}`);
      });
    } else if (this.warnings.length > 0) {
      console.log(`\n${colors.yellow}‚ö†Ô∏è  R√âSULTAT: PR√äT AVEC R√âSERVES${colors.reset}`);
      console.log('Recommandations:');
      this.warnings.forEach(warning => {
        console.log(`  ‚Ä¢ ${warning}`);
      });
    } else {
      console.log(`\n${colors.green}‚úÖ R√âSULTAT: PR√äT POUR TESTFLIGHT!${colors.reset}`);
      console.log('L\'application peut √™tre soumise √† Apple TestFlight.');
    }
    
    // Sauvegarder le rapport
    const reportData = {
      date: new Date().toISOString(),
      successes: this.successes.length,
      warnings: this.warnings.length,
      errors: this.errors.length,
      criticalIssues: this.criticalIssues,
      successRate: successRate,
      ready: this.criticalIssues === 0,
      details: {
        successes: this.successes,
        warnings: this.warnings,
        errors: this.errors
      }
    };
    
    fs.writeFileSync('testflight-validation-report.json', JSON.stringify(reportData, null, 2));
    console.log('\nüìÑ Rapport sauvegard√©: testflight-validation-report.json');
  }

  // Lancer toutes les validations
  async run() {
    console.log(colors.magenta + '\nüöÄ Validation TestFlight - And Friends v1.0.0\n' + colors.reset);
    
    this.checkTypeScript();
    this.checkTests();
    this.checkLinting();
    this.checkDependencies();
    this.checkConfiguration();
    this.checkAssets();
    this.checkBuilds();
    await this.checkSupabaseSecurity();
    
    this.generateReport();
  }
}

// Lancer la validation
const validator = new TestFlightValidator();
validator.run().catch(error => {
  console.error(colors.red + 'Erreur lors de la validation:', error + colors.reset);
  process.exit(1);
});